<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <title>leetcode-数据结构-线性表</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="A Pelican Blog Atom Feed" />

        <!--[if IE]>
            <script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">A Pelican Blog </a></h1>
                <nav><ul>
                    <li><a href="/category/dai-ma-you-hua.html">代码优化</a></li>
                    <li><a href="/category/ji-suan-ji-ji-chu.html">计算机基础</a></li>
                    <li><a href="/category/python.html">Python</a></li>
                    <li class="active"><a href="/category/shu-ju-jie-gou.html">数据结构</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/leetcode-shu-ju-jie-gou-xian-xing-biao.html" rel="bookmark"
           title="Permalink to leetcode-数据结构-线性表">leetcode-数据结构-线性表</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2016-07-09T10:20:00+00:00">
                Published: 六 09 七月 2016
        </abbr>

<p>In <a href="/category/shu-ju-jie-gou.html">数据结构</a>.</p>
<p>tags: <a href="/tag/python.html">Python</a> <a href="/tag/shu-ju-jie-gou.html">数据结构</a> </p>
</footer><!-- /.post-info -->      <h4>19 . Remove Nth Node From End of List</h4>
<p><code>Given a linked list, remove the *n*th
 node from the end of list and return its head.</code>
<strong> For example, </strong></p>
<blockquote>
<p>Given linked list: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, and <strong><em>n</em> = 2</strong>. After removing the second node from the end, the linked list becomes <strong>1-&gt;2-&gt;3-&gt;5</strong>.</p>
<p><strong>Note:</strong>Given <em>n</em> will always be valid.Try to do this in one pass.</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="err">#</span> <span class="nx">Definition</span> <span class="k">for</span> <span class="nx">singly</span><span class="o">-</span><span class="nx">linked</span> <span class="nx">list</span><span class="p">.</span>
<span class="err">#</span> <span class="kr">class</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>     <span class="nx">def</span> <span class="nx">__init__</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">x</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">None</span>

<span class="kr">class</span> <span class="nx">Solution</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
    <span class="nx">def</span> <span class="nx">removeNthFromEnd</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">head</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span><span class="o">:</span>
        <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        :type head: ListNode</span>
<span class="s2">        :type n: int</span>
<span class="s2">        :rtype: ListNode</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="nx">cur1</span> <span class="o">=</span> <span class="nx">head</span>
        <span class="nx">cur2</span> <span class="o">=</span> <span class="nx">head</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">range</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span><span class="o">:</span>
            <span class="err">#</span> <span class="err">定义两个</span><span class="nx">cur</span><span class="p">,</span> <span class="err">使得这两个</span><span class="nx">cur相距为N</span>
            <span class="k">if</span> <span class="nx">cur2.next</span>:
                <span class="kt">cur2</span> <span class="o">=</span> <span class="nx">cur2</span><span class="p">.</span><span class="nx">next</span>
            <span class="nx">elif</span> <span class="nx">n</span> <span class="o">-</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">1</span><span class="o">:</span>
            <span class="err">#</span> <span class="err">如果删除第一个元素</span>
                <span class="k">return</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
            <span class="k">else</span><span class="o">:</span>
                <span class="k">return</span> <span class="nx">None</span>

        <span class="k">while</span> <span class="nx">cur2</span><span class="p">.</span><span class="nx">next</span><span class="o">:</span>
            <span class="err">#</span> <span class="err">同时移动之两个</span><span class="nx">cur</span><span class="p">,</span> <span class="err">使得</span><span class="nx">cur2到达list底端</span>
            <span class="nx">cur2</span> <span class="o">=</span> <span class="nx">cur2</span><span class="p">.</span><span class="nx">next</span>
            <span class="nx">cur1</span> <span class="o">=</span> <span class="nx">cur1</span><span class="p">.</span><span class="nx">next</span>

        <span class="nx">cur1</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">cur1</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span>
        <span class="k">return</span> <span class="nx">head</span>
</pre></div>


<ul>
<li>解析
<code>这道题目是删除列表中的倒数第N个元素， 刚看到题目的的时候， 觉得最简单的做法是先遍历一边， 求出list的长度， 然后根据N的值判断出要删除元素的位置。但仔细想想， 这样做有点牵妥，因为要得未知list的长度， 那么你首先要遍历一遍List, 然后删除目标元素又要遍历一遍， 这样总共要遍历两遍。
但是经过思考， 我找到了遍历一遍的方法：</code></li>
<li>定义两个cur, 使得这两个cur相距为N</li>
</ul>
<div class="highlight"><pre><span></span>  head 
   |
   1 -&gt; 2 -&gt; 3 -&gt; 4-&gt; 5
   |         |
 cur1     cur2
</pre></div>


<ol>
<li>同时移动之两个cur, 使得cur2到达list底端</li>
</ol>
<div class="highlight"><pre><span></span>  head 
   |
   1 -&gt; 2 -&gt; 3 -&gt; 4-&gt; 5
              |       |
            cur1     cur2
</pre></div>


<ol>
<li>删除cur1的下一个元素<code>cur1.next = cur1.next.next</code></li>
</ol>
<div class="highlight"><pre><span></span>  head 
   |
   1 -&gt; 2 -&gt; 3 -&gt; 5
              |   |
            cur1 cur2
</pre></div>


<p>33</p>
<p><code>这样， 定义两个cur， 就可以通过一次遍历就可以删除倒数第N个元素了。</code></p>
<hr>
<h3>21. Merge Two Sorted Lists</h3>
<blockquote>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="err">#</span> <span class="nx">Definition</span> <span class="k">for</span> <span class="nx">singly</span><span class="o">-</span><span class="nx">linked</span> <span class="nx">list</span><span class="p">.</span>
<span class="err">#</span> <span class="kr">class</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>     <span class="nx">def</span> <span class="nx">__init__</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">x</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">None</span>

<span class="kr">class</span> <span class="nx">Solution</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
    <span class="nx">def</span> <span class="nx">mergeTwoLists</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">l1</span><span class="p">,</span> <span class="nx">l2</span><span class="p">)</span><span class="o">:</span>
        <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        :type l1: ListNode</span>
<span class="s2">        :type l2: ListNode</span>
<span class="s2">        :rtype: ListNode</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nx">l1</span> <span class="nx">is</span> <span class="nx">None</span>:
            <span class="kt">return</span> <span class="nx">l2</span>

        <span class="k">if</span> <span class="nx">l2</span> <span class="nx">is</span> <span class="nx">None</span>:
            <span class="kt">return</span> <span class="nx">l1</span>

        <span class="k">if</span> <span class="nx">l1</span><span class="p">.</span><span class="nx">val</span> <span class="o">&lt;</span> <span class="nx">l2.val</span>:
            <span class="kt">l1.next</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">mergeTwoLists</span><span class="p">(</span><span class="nx">l1</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> <span class="nx">l2</span><span class="p">)</span>
            <span class="k">return</span> <span class="nx">l1</span>
        <span class="k">else</span><span class="o">:</span>
            <span class="nx">l2</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">mergeTwoLists</span><span class="p">(</span><span class="nx">l1</span><span class="p">,</span> <span class="nx">l2</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span>
            <span class="k">return</span> <span class="nx">l2</span>
</pre></div>


<ul>
<li>解析</li>
</ul>
<p><code>这道提是要合并两个有序链表， 常规做法是先判断节点大小， 然后再插入。 但是还有递归的做法， 递归的主要做法就是， 每次找出两个List中最小的那个值， 然后合并剩下的（l1.next = self.mergeTwoLists(l1.next, l2）。 递归的思路不难， 但描述起来比较麻烦， 多看几遍代码就能明白递归的奥妙。</code></p>
<h3>61. Rotate List</h3>
<blockquote>
<p>Given a list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.
For example:
Given <strong>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</strong>
 and <strong>k = 2</strong>,
return <strong>4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</strong></p>
</blockquote>
<div class="highlight"><pre><span></span><span class="err">#</span> <span class="nx">Definition</span> <span class="k">for</span> <span class="nx">singly</span><span class="o">-</span><span class="nx">linked</span> <span class="nx">list</span><span class="p">.</span>
<span class="err">#</span> <span class="kr">class</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>     <span class="nx">def</span> <span class="nx">__init__</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">x</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">None</span>

<span class="kr">class</span> <span class="nx">Solution</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
    <span class="nx">def</span> <span class="nx">rotateRight</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">head</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span><span class="o">:</span>
        <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        :type head: ListNode</span>
<span class="s2">        :type k: int</span>
<span class="s2">        :rtype: ListNode</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nx">head</span> <span class="nx">is</span> <span class="nx">None</span>:
            <span class="kt">return</span> <span class="nx">head</span>
        <span class="nx">l</span><span class="p">,</span> <span class="nx">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">head</span>
        <span class="k">while</span> <span class="nx">p.next</span>:
            <span class="kt">p</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">next</span>
            <span class="nx">l</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nx">k</span> <span class="o">=</span> <span class="nx">k</span> <span class="o">%</span> <span class="nx">l</span>
        <span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">0</span>:
            <span class="kt">return</span> <span class="nx">head</span>

        <span class="nx">q</span><span class="p">,</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">head</span><span class="p">,</span> <span class="nx">l</span> <span class="o">-</span> <span class="nx">k</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="nx">n</span>:
            <span class="kt">q</span> <span class="o">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">next</span>
            <span class="nx">n</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="nx">p</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">head</span>
        <span class="nx">head</span> <span class="o">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">next</span>
        <span class="nx">q</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">None</span>
        <span class="k">return</span> <span class="nx">head</span>
</pre></div>


<h3>82. Remove Duplicates from Sorted List II</h3>
<blockquote>
<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.
For example,Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5
return 1-&gt;2-&gt;5
Given 1-&gt;1-&gt;1-&gt;2-&gt;3
 return 2-&gt;3</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="err">#</span> <span class="nx">Definition</span> <span class="k">for</span> <span class="nx">singly</span><span class="o">-</span><span class="nx">linked</span> <span class="nx">list</span><span class="p">.</span>
<span class="err">#</span> <span class="kr">class</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>     <span class="nx">def</span> <span class="nx">__init__</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">x</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">None</span>

<span class="kr">class</span> <span class="nx">Solution</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
    <span class="nx">def</span> <span class="nx">deleteDuplicates</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">head</span><span class="p">)</span><span class="o">:</span>
        <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        :type head: ListNode</span>
<span class="s2">        :rtype: ListNode</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nx">not</span> <span class="nx">head</span> <span class="nx">or</span> <span class="nx">not</span> <span class="nx">head.next</span>:
            <span class="kt">return</span> <span class="nx">head</span>

        <span class="nx">before</span> <span class="o">=</span> <span class="nx">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="nx">before</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">head</span>
        <span class="nx">head</span> <span class="o">=</span> <span class="nx">before</span> 
        <span class="nx">after</span> <span class="o">=</span>  <span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
        <span class="k">while</span> <span class="nx">after</span> <span class="nx">and</span> <span class="nx">after.next</span>:
            <span class="kt">if</span> <span class="nx">before</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">val</span> <span class="o">==</span> <span class="nx">after.next.val</span>:
                <span class="kt">while</span> <span class="nx">after</span><span class="p">.</span><span class="nx">next</span> <span class="nx">and</span> <span class="nx">before</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">val</span> <span class="o">==</span> <span class="nx">after.next.val</span>:
                    <span class="kt">after</span> <span class="o">=</span> <span class="nx">after</span><span class="p">.</span><span class="nx">next</span>
                <span class="nx">before</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">after</span><span class="p">.</span><span class="nx">next</span>  
                <span class="nx">after</span> <span class="o">=</span> <span class="nx">after</span><span class="p">.</span><span class="nx">next</span>
            <span class="k">else</span><span class="o">:</span>
                <span class="nx">before</span> <span class="o">=</span> <span class="nx">before</span><span class="p">.</span><span class="nx">next</span>
                <span class="nx">after</span> <span class="o">=</span> <span class="nx">after</span><span class="p">.</span><span class="nx">next</span>
        <span class="nx">head</span> <span class="o">=</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
        <span class="k">return</span> <span class="nx">head</span>
</pre></div>


<p>解析</p>
<p>给定链表 <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;4-&gt;5</code> 我们如果要删除重复元素 ， 首先要找出重复元素。最笨的方法当然是先遍历一遍找到重复的元素， 然后将重复的元素记录下来， 最后再删除重复的元素。但给定列表是有序的，其实也可以边遍历边删除，做法就是判断当前元素跟下一个元素是否一样， 如果一样则有重复出现。
* 如何寻找重复的数字？
   ```</p>
<p>3-&gt;4-&gt;4-&gt;4-&gt;5<br>
     |  |
     B  F
如果B节点跟F节点的值一样， 则表示重复
然后移动 F节点， 直到F节点的值跟B节点的值不一样
  3-&gt;4-&gt;4-&gt;4-&gt;5<br>
     |        |
     B        F
此时[B,F)中的节点的值全为4
那么直接将B的上一节点的的next 置为F所在的节点， 就可以删除所有值为四的节点了。
 ```</p>
<h3>83. Remove Duplicates from Sorted List</h3>
<blockquote>
<p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.
For example,Given <strong>1-&gt;1-&gt;2,</strong>
 return <strong>1-&gt;2</strong>.
Given <strong>1-&gt;1-&gt;2-&gt;3-&gt;3</strong>,
 return <strong>1-&gt;2-&gt;3</strong></p>
</blockquote>
<div class="highlight"><pre><span></span><span class="err">#</span> <span class="nx">Definition</span> <span class="k">for</span> <span class="nx">singly</span><span class="o">-</span><span class="nx">linked</span> <span class="nx">list</span><span class="p">.</span>
<span class="err">#</span> <span class="kr">class</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>     <span class="nx">def</span> <span class="nx">__init__</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">x</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">None</span>

<span class="kr">class</span> <span class="nx">Solution</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
    <span class="nx">def</span> <span class="nx">deleteDuplicates</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">head</span><span class="p">)</span><span class="o">:</span>
        <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        :type head: ListNode</span>
<span class="s2">        :rtype: ListNode</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nx">not</span> <span class="nx">head</span>:
            <span class="kt">return</span> <span class="nx">head</span>
        <span class="nx">before</span>  <span class="o">=</span> <span class="nx">head</span>
        <span class="nx">after</span> <span class="o">=</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
        <span class="k">while</span> <span class="nx">before</span> <span class="nx">and</span> <span class="nx">after</span> :
            <span class="kt">if</span> <span class="nx">before</span><span class="p">.</span><span class="nx">val</span> <span class="o">==</span> <span class="nx">after.val</span>:
                <span class="kt">while</span> <span class="nx">before</span><span class="p">.</span><span class="nx">val</span> <span class="o">==</span> <span class="nx">after.val</span>:
                    <span class="kt">after</span> <span class="o">=</span> <span class="nx">after</span><span class="p">.</span><span class="nx">next</span>
                    <span class="k">if</span> <span class="nx">not</span> <span class="nx">after</span>:
                        <span class="kt">before.next</span> <span class="o">=</span> <span class="nx">None</span>
                        <span class="k">return</span> <span class="nx">head</span>
                <span class="nx">before</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">after</span>
            <span class="nx">before</span> <span class="o">=</span> <span class="nx">before</span><span class="p">.</span><span class="nx">next</span>
            <span class="nx">after</span> <span class="o">=</span> <span class="nx">after</span><span class="p">.</span><span class="nx">next</span>
        <span class="k">return</span> <span class="nx">head</span>
</pre></div>


<h3>86. Partition List</h3>
<blockquote>
<p>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.
You should preserve the original relative order of the nodes in each of the two partitions.
For example,
Given <strong>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2</strong> and <strong> <em>x</em> = 3</strong>,
return <strong>1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</strong></p>
</blockquote>
<div class="highlight"><pre><span></span><span class="err">#</span> <span class="nx">Definition</span> <span class="k">for</span> <span class="nx">singly</span><span class="o">-</span><span class="nx">linked</span> <span class="nx">list</span><span class="p">.</span>
<span class="err">#</span> <span class="kr">class</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>     <span class="nx">def</span> <span class="nx">__init__</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">x</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">None</span>

<span class="kr">class</span> <span class="nx">Solution</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
    <span class="nx">def</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">head</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span><span class="o">:</span>
        <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        :type head: ListNode</span>
<span class="s2">        :type x: int</span>
<span class="s2">        :rtype: ListNode</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="nx">cur</span> <span class="o">=</span> <span class="nx">head</span>
        <span class="nx">p</span> <span class="o">=</span> <span class="nx">None</span>
        <span class="nx">q</span> <span class="o">=</span> <span class="nx">None</span>
        <span class="nx">p_cur</span> <span class="o">=</span> <span class="nx">None</span>
        <span class="nx">q_cur</span> <span class="o">=</span> <span class="nx">None</span>

        <span class="k">while</span> <span class="nx">cur</span>:
            <span class="kt">if</span> <span class="nx">x</span> <span class="o">&gt;</span> <span class="nx">cur.val</span>:
                <span class="kt">if</span> <span class="nx">not</span> <span class="nx">p</span>:
                    <span class="kt">p</span> <span class="o">=</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">cur</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
                <span class="k">else</span><span class="o">:</span>
                    <span class="k">if</span> <span class="nx">not</span> <span class="nx">p_cur</span>:
                        <span class="kt">p_cur</span> <span class="o">=</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">cur</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
                        <span class="nx">p</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">p_cur</span>
                    <span class="k">else</span><span class="o">:</span>
                        <span class="nx">p_cur</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">cur</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
                        <span class="nx">p_cur</span> <span class="o">=</span> <span class="nx">p_cur</span><span class="p">.</span><span class="nx">next</span>
            <span class="k">else</span><span class="o">:</span>
                <span class="k">if</span> <span class="nx">not</span> <span class="nx">q</span>:
                    <span class="kt">q</span> <span class="o">=</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">cur</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
                <span class="k">else</span><span class="o">:</span>
                    <span class="k">if</span> <span class="nx">not</span> <span class="nx">q_cur</span>:
                        <span class="kt">q_cur</span> <span class="o">=</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">cur</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
                        <span class="nx">q</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">q_cur</span>
                    <span class="k">else</span><span class="o">:</span>
                        <span class="nx">q_cur</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">cur</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
                        <span class="nx">q_cur</span> <span class="o">=</span> <span class="nx">q_cur</span><span class="p">.</span><span class="nx">next</span>
            <span class="nx">cur</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span>
        <span class="k">if</span> <span class="nx">p_cur</span>:
            <span class="kt">p_cur.next</span> <span class="o">=</span> <span class="nx">q</span>
            <span class="k">return</span> <span class="nx">p</span>
        <span class="nx">elif</span> <span class="nx">p</span>:
            <span class="kt">return</span> <span class="nx">p</span>
        <span class="k">else</span><span class="o">:</span>
            <span class="k">return</span> <span class="nx">q</span>


<span class="err">#</span> <span class="nx">Definition</span> <span class="k">for</span> <span class="nx">singly</span><span class="o">-</span><span class="nx">linked</span> <span class="nx">list</span><span class="p">.</span>
<span class="err">#</span> <span class="kr">class</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>     <span class="nx">def</span> <span class="nx">__init__</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">x</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">None</span>

<span class="kr">class</span> <span class="nx">Solution</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
    <span class="nx">def</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">head</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span><span class="o">:</span>
        <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        :type head: ListNode</span>
<span class="s2">        :type x: int</span>
<span class="s2">        :rtype: ListNode</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="nx">dummySmaller</span><span class="p">,</span> <span class="nx">dummyGreater</span> <span class="o">=</span> <span class="nx">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="nx">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="nx">smaller</span><span class="p">,</span> <span class="nx">greater</span> <span class="o">=</span> <span class="nx">dummySmaller</span><span class="p">,</span> <span class="nx">dummyGreater</span>

        <span class="k">while</span> <span class="nx">head</span>:
            <span class="kt">if</span> <span class="nx">head</span><span class="p">.</span><span class="nx">val</span> <span class="o">&lt;</span> <span class="nx">x</span>:
                <span class="kt">smaller.next</span> <span class="o">=</span> <span class="nx">head</span>
                <span class="nx">smaller</span> <span class="o">=</span> <span class="nx">smaller</span><span class="p">.</span><span class="nx">next</span>
            <span class="k">else</span><span class="o">:</span>
                <span class="nx">greater</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">head</span>
                <span class="nx">greater</span> <span class="o">=</span> <span class="nx">greater</span><span class="p">.</span><span class="nx">next</span>
            <span class="nx">head</span> <span class="o">=</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span>

        <span class="nx">smaller</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">dummyGreater</span><span class="p">.</span><span class="nx">next</span>
        <span class="nx">greater</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">None</span>
        <span class="k">return</span> <span class="nx">dummySmaller</span><span class="p">.</span><span class="nx">next</span>
</pre></div>


<h3>92. Reverse Linked List II</h3>
<blockquote>
<p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in-place and in one-pass.
For example:
Given <strong>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</strong>, <strong><em>m</em> = 2 and <em>n</em> = 4</strong>,
return <strong>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</strong></p>
</blockquote>
<div class="highlight"><pre><span></span><span class="err">#</span> <span class="nx">Definition</span> <span class="k">for</span> <span class="nx">singly</span><span class="o">-</span><span class="nx">linked</span> <span class="nx">list</span><span class="p">.</span>
<span class="err">#</span> <span class="kr">class</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>     <span class="nx">def</span> <span class="nx">__init__</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">x</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">None</span>

<span class="kr">class</span> <span class="nx">Solution</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
    <span class="nx">def</span> <span class="nx">reverseBetween</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">head</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span><span class="o">:</span>
        <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        :type head: ListNode</span>
<span class="s2">        :type m: int</span>
<span class="s2">        :type n: int</span>
<span class="s2">        :rtype: ListNode</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="nx">dummyHead</span> <span class="o">=</span> <span class="nx">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="nx">_head</span> <span class="o">=</span> <span class="nx">dummyHead</span> 
        <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">while</span> <span class="nx">head</span>:
            <span class="kt">if</span> <span class="nx">i</span> <span class="o">&gt;=</span><span class="nx">m</span> <span class="nx">and</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span>:
                <span class="kt">cur</span> <span class="o">=</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">head</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
                <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">_head</span><span class="p">.</span><span class="nx">next</span>
                <span class="nx">_head</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">cur</span>
                <span class="k">if</span> <span class="nx">i</span><span class="o">==</span> <span class="nx">m</span>:
                    <span class="kt">_last</span> <span class="o">=</span> <span class="nx">cur</span>
                    <span class="nx">_last</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">None</span>
            <span class="nx">elif</span> <span class="nx">i</span><span class="o">&gt;</span> <span class="nx">n</span>:
                <span class="kt">_last.next</span> <span class="o">=</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">head</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
                <span class="nx">_last</span> <span class="o">=</span> <span class="nx">_last</span><span class="p">.</span><span class="nx">next</span>
            <span class="k">else</span><span class="o">:</span>
                <span class="nx">_head</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">head</span>
                <span class="nx">_head</span> <span class="o">=</span> <span class="nx">_head</span><span class="p">.</span><span class="nx">next</span>
            <span class="nx">head</span> <span class="o">=</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span>

            <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="nx">dummyHead</span><span class="p">.</span><span class="nx">next</span>
</pre></div>


<h3>147. Insertion Sort List</h3>
<blockquote>
<p>Sort a linked list using insertion sort.</p>
</blockquote>
<p><a href="https://leetcode.com/subscribe/">Subscribe</a> to see which companies asked this question</p>
<div class="highlight"><pre><span></span><span class="err">#</span> <span class="nx">Definition</span> <span class="k">for</span> <span class="nx">singly</span><span class="o">-</span><span class="nx">linked</span> <span class="nx">list</span><span class="p">.</span>
<span class="err">#</span> <span class="kr">class</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>     <span class="nx">def</span> <span class="nx">__init__</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">x</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">None</span>

<span class="kr">class</span> <span class="nx">Solution</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
    <span class="nx">def</span> <span class="nx">insertionSortList</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">head</span><span class="p">)</span><span class="o">:</span>
        <span class="nx">p</span> <span class="o">=</span> <span class="nx">dummy</span> <span class="o">=</span> <span class="nx">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="nx">cur</span> <span class="o">=</span> <span class="nx">dummy</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">head</span>
        <span class="k">while</span> <span class="nx">cur</span> <span class="nx">and</span> <span class="nx">cur.next</span>:
            <span class="kt">val</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">val</span>
            <span class="k">if</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">val</span> <span class="o">&lt;</span> <span class="nx">val</span>:
                <span class="kt">cur</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">val</span> <span class="o">&gt;</span> <span class="nx">val</span>:
                <span class="kt">p</span> <span class="o">=</span> <span class="nx">dummy</span>
            <span class="k">while</span> <span class="nx">p</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">val</span> <span class="o">&lt;</span> <span class="nx">val</span>:
                <span class="kt">p</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">next</span>
            <span class="k">new</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span>
            <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">new</span><span class="p">.</span><span class="nx">next</span>
            <span class="k">new</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">next</span>
            <span class="nx">p</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">new</span>
        <span class="k">return</span> <span class="nx">dummy</span><span class="p">.</span><span class="nx">next</span>

<span class="err">##########################</span>
<span class="err">#</span> <span class="nx">Definition</span> <span class="k">for</span> <span class="nx">singly</span><span class="o">-</span><span class="nx">linked</span> <span class="nx">list</span><span class="p">.</span>
<span class="err">#</span> <span class="kr">class</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>     <span class="nx">def</span> <span class="nx">__init__</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">x</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">None</span>

<span class="kr">class</span> <span class="nx">Solution</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
    <span class="nx">def</span> <span class="nx">insertionSortList</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">head</span><span class="p">)</span><span class="o">:</span>
        <span class="nx">cur</span> <span class="o">=</span> <span class="nx">head</span>
        <span class="k">while</span> <span class="nx">cur</span>:
            <span class="kt">cur_next</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span>
            <span class="k">while</span> <span class="nx">cur_next</span>:
                <span class="kt">if</span> <span class="nx">cur_next</span><span class="p">.</span><span class="nx">val</span> <span class="o">&lt;</span> <span class="nx">cur.val</span>:
                    <span class="kt">cur_next.val</span><span class="p">,</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">val</span><span class="p">,</span> <span class="nx">cur_next</span><span class="p">.</span><span class="nx">val</span>
                <span class="nx">cur_next</span> <span class="o">=</span> <span class="nx">cur_next</span><span class="p">.</span><span class="nx">next</span>
            <span class="nx">cur</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span>
        <span class="k">return</span> <span class="nx">head</span>    
</pre></div>


<p>第二种做法会超时， 这个问题在Leetcode上有人也说出来了。 如果将第二种Python代码翻译成Java代码的话， 是可以运行通过的。换成Python就不能通过了。
第一种做法明显的提升了时间复杂度， 它减少了不必要的比较。 以及循环次数。 
如 对于这样的List ：3-&gt;7-&gt; 5-&gt;-9-&gt;4
1.  先找到5 , 将5 插入到 7 前面
    3-&gt; 5-&gt;7-&gt;9 -&gt;4
2.  再找到4 将4插入到5前面
3-&gt; 4-&gt; 5-&gt; 7-&gt;9
它会查找不正确顺序节点， 然后将该结点插入到适当位置。所以优化了传统的插入排序。</p>
<h3>160. Intersection of Two Linked Lists</h3>
<blockquote>
<p><code>Write a program to find the node at which the intersection of two singly linked lists begins.
For example, the following two linked lists:</code></p>
</blockquote>
<div class="highlight"><pre><span></span><span class="n">A</span><span class="o">:</span>          <span class="n">a1</span> <span class="err">→</span> <span class="n">a2</span>
                   <span class="err">↘</span>
                     <span class="n">c1</span> <span class="err">→</span> <span class="n">c2</span> <span class="err">→</span> <span class="n">c3</span>
                   <span class="err">↗</span>            
<span class="n">B</span><span class="o">:</span>     <span class="n">b1</span> <span class="err">→</span> <span class="n">b2</span> <span class="err">→</span> <span class="n">b3</span>
</pre></div>


<p>begin to intersect at node c1.
<strong>Notes:</strong>
If the two linked lists have no intersection at all, return null.
The linked lists must retain their original structure after the function returns.
You may assume there are no cycles anywhere in the entire linked structure.
Your code should preferably run in O(n) time and use only O(1) memory.</p>
<p><strong>Credits:</strong>Special thanks to <a href="https://oj.leetcode.com/discuss/user/stellari">@stellari</a> for adding this problem and creating all test cases.</p>
<p><a href="https://leetcode.com/subscribe/">Subscribe</a> to see which companies asked this question</p>
<div class="highlight"><pre><span></span><span class="err">#</span> <span class="nx">Definition</span> <span class="k">for</span> <span class="nx">singly</span><span class="o">-</span><span class="nx">linked</span> <span class="nx">list</span><span class="p">.</span>
<span class="err">#</span> <span class="kr">class</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>     <span class="nx">def</span> <span class="nx">__init__</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">x</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">None</span>

<span class="kr">class</span> <span class="nx">Solution</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
    <span class="nx">def</span> <span class="nx">getListLength</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">head</span><span class="p">)</span><span class="o">:</span>
        <span class="nx">length</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="nx">head</span>:
            <span class="kt">head</span> <span class="o">=</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
            <span class="nx">length</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nx">length</span>

    <span class="nx">def</span> <span class="nx">getIntersectionNode</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">headA</span><span class="p">,</span> <span class="nx">headB</span><span class="p">)</span><span class="o">:</span>
        <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        :type head1, head1: ListNode</span>
<span class="s2">        :rtype: ListNode</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="nx">lengthA</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">getListLength</span><span class="p">(</span><span class="nx">headA</span><span class="p">)</span>
        <span class="nx">lengthB</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">getListLength</span><span class="p">(</span><span class="nx">headB</span><span class="p">)</span>
        <span class="nx">curA</span> <span class="o">=</span> <span class="nx">headA</span>
        <span class="nx">curB</span> <span class="o">=</span> <span class="nx">headB</span>

        <span class="k">if</span> <span class="nx">lengthA</span> <span class="o">&gt;</span> <span class="nx">lengthB</span>:
            <span class="kt">for</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">range</span><span class="p">(</span><span class="nx">lengthA</span> <span class="o">-</span> <span class="nx">lengthB</span><span class="p">)</span><span class="o">:</span>
                <span class="nx">curA</span> <span class="o">=</span> <span class="nx">curA</span><span class="p">.</span><span class="nx">next</span>
        <span class="nx">elif</span> <span class="nx">lengthA</span> <span class="o">&lt;</span> <span class="nx">lengthB</span>:
            <span class="kt">for</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">range</span><span class="p">(</span><span class="nx">lengthB</span> <span class="o">-</span> <span class="nx">lengthA</span><span class="p">)</span><span class="o">:</span>
                <span class="nx">curB</span> <span class="o">=</span> <span class="nx">curB</span><span class="p">.</span><span class="nx">next</span>

        <span class="k">while</span> <span class="nx">curA</span> <span class="nx">and</span> <span class="nx">curB</span>:
            <span class="kt">if</span> <span class="nx">curA</span> <span class="o">==</span> <span class="nx">curB</span>:
                <span class="kt">return</span> <span class="nx">curA</span> 
            <span class="nx">curA</span> <span class="o">=</span> <span class="nx">curA</span><span class="p">.</span><span class="nx">next</span>
            <span class="nx">curB</span> <span class="o">=</span> <span class="nx">curB</span><span class="p">.</span><span class="nx">next</span>

        <span class="k">return</span> <span class="nx">None</span>
</pre></div>


<ul>
<li>暴力破解：通过双循环遍历 ， 找到结点 时间复杂度为O（lengthA * lengthB）</li>
<li>哈希法 ： 记录A的结点， 再从B中找出一结点， 该结点位于A中。 时间复杂度为O（lengthA + lengthB） 空间复杂度为O（lengthA or lengthB）</li>
<li>双指针 遍历链表A，记录其长度lengthA，遍历链表B，记录其长度lengthB。
因为两个链表的长度可能不相同，比如题目所给的case，lengthA=5，lengthB=6，则作差得到 lengthB- lengthA=1，将指针pb从链表B的首节点开始走1步，即指向了第二个节点，pa指向链表A首节点，然后它们同时走，每次都走一步，当它们相等时，就是交集的节点。
时间复杂度O(lengthA+lengthB)，空间复杂度O(1)</li>
</ul>
<h3>203. Remove Linked List Elements</h3>
<blockquote>
<p>Remove all elements from a linked list of integers that have value <strong><em>val</em></strong>.
<strong>Example</strong>
<strong><em>Given:</em></strong> 1 --&gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6,
 <strong><em>val</em></strong> = 6
<strong><em>Return:</em></strong> 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5</p>
</blockquote>
<p><a href="https://leetcode.com/subscribe/">Subscribe</a> to see which companies asked this question</p>
<div class="highlight"><pre><span></span><span class="err">#</span> <span class="nx">Definition</span> <span class="k">for</span> <span class="nx">singly</span><span class="o">-</span><span class="nx">linked</span> <span class="nx">list</span><span class="p">.</span>
<span class="err">#</span> <span class="kr">class</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>     <span class="nx">def</span> <span class="nx">__init__</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span><span class="o">:</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">x</span>
<span class="err">#</span>         <span class="nx">self</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">None</span>

<span class="kr">class</span> <span class="nx">Solution</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>
    <span class="nx">def</span> <span class="nx">removeElements</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">head</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span><span class="o">:</span>
        <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        :type head: ListNode</span>
<span class="s2">        :type val: int</span>
<span class="s2">        :rtype: ListNode</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="nx">ptr</span> <span class="o">=</span> <span class="nx">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="nx">ptr</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">head</span>
        <span class="nx">cur</span> <span class="o">=</span> <span class="nx">ptr</span>

        <span class="k">while</span> <span class="nx">cur</span> <span class="nx">and</span> <span class="nx">cur.next</span>:
            <span class="kt">if</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">val</span> <span class="o">==</span> <span class="nx">val</span>:
                <span class="kt">cur.next</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span>
                <span class="k">continue</span>
            <span class="nx">cur</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span>
        <span class="k">return</span> <span class="nx">ptr</span><span class="p">.</span><span class="nx">next</span>
    <span class="sb">```</span>
<span class="sb">`</span>
<span class="err">第一次提交的时候没有加</span> <span class="k">continue</span> <span class="err">，</span> <span class="err">当遇到测试用例</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="err">的时候，</span> <span class="err">预期答案应该是</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="err">而我返回的是</span><span class="p">[]</span><span class="err">。</span> <span class="err">经过分析，</span> <span class="err">当删除了一个元素后，</span> <span class="err">指针不应当往后移动，</span> <span class="err">因为如果删除元素后同时移动指针的话，</span> <span class="err">会忽略被删除元素之后的那个元素的存在。</span>
<span class="sb">`</span>
<span class="sb">### 206. Reverse Linked List</span>

<span class="sb">&gt; Reverse a singly linked list.</span>
</pre></div>


<h1>Definition for singly-linked list.</h1>
<h1>class ListNode(object):</h1>
<h1>def <strong>init</strong>(self, x):</h1>
<h1>self.val = x</h1>
<h1>self.next = None</h1>
<p>class Solution(object):
    def reverseList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        cur = ListNode(-1)
        cur.next = head
        reverse = None
        while cur.next:
            cur_next = cur.next
            cur.next = cur.next.next
            cur_next.next = reverse
            reverse = cur_next
        return reverse</p>
<div class="highlight"><pre><span></span>遍历列表， 并将遍历的元素放到最前面。竟然一次性功过
### 234. Palindrome Linked List
 &gt; Given a singly linked list, determine if it is a palindrome.
**Follow up:**Could you do it in O(n) time and O(1) space?
</pre></div>


<h1>Definition for singly-linked list.</h1>
<h1>class ListNode(object):</h1>
<h1>def <strong>init</strong>(self, x):</h1>
<h1>self.val = x</h1>
<h1>self.next = None</h1>
<p>class Solution(object):</p>
<div class="highlight"><pre><span></span>def reverseList(self, head):
    &quot;&quot;&quot;
    :type head: ListNode
    :rtype: ListNode
    &quot;&quot;&quot;
    cur = ListNode(-1)
    cur.next = head
    reverse = None
    while cur.next:
        cur_next = cur.next
        cur.next = cur.next.next
        cur_next.next = reverse
        reverse = cur_next
    return reverse

def isPalindrome(self, head):
    &quot;&quot;&quot;
    :type head: ListNode
    :rtype: bool
    &quot;&quot;&quot;
    fast = head
    slow = head
    while fast and fast.next:
        # 用快慢指针的方法， 获得后半段列表
        fast = fast.next.next
        slow = slow.next

    if fast:
        reverse = self.reverseList(slow.next)
    else:
        reverse = self.reverseList(slow)

    while reverse:
        if head.val != reverse.val:
            return False
        head = head.next
        reverse = reverse.next
    return True
</pre></div>


<div class="highlight"><pre><span></span>`
判断一个列表是不是回文， 目标是时间复杂度为O(n), 空间复杂度为O(1)  , 最好的方法是反转后半段， 然后判前半段列表跟后半段列表是否相等。 
`
###237. Delete Node in a Linked List
 
&gt; Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.
Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4
 and you are given the third node with value 3
, the linked list should become 1 -&gt; 2 -&gt; 4
after calling your function.

[Subscribe](https://leetcode.com/subscribe/) to see which companies asked this question
</pre></div>


<h1>Definition for singly-linked list.</h1>
<h1>class ListNode(object):</h1>
<h1>def <strong>init</strong>(self, x):</h1>
<h1>self.val = x</h1>
<h1>self.next = None</h1>
<p>class Solution(object):
    def deleteNode(self, node):
        """
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """
        node.val = node.next.val
        node.next = node.next.next
```</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>